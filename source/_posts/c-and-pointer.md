---
layout: 'post'
title: 'c和指针'
date: 2020-12-12 15:11:33
tags: 'c pointer'
excerpt: '抄录《c和指针》'
---

# c和指针



## 1. 快速上手

### 1.1.1 空白和注释

#### 空白 - 清晰的显示程序的结构

> 空行将程序的不同部分分割开来；制表符（tab）用于缩进语句，更好的显示程序的结构等等。
>
> C是一种自由格式的语言，并没有规则要求你必须怎样书写语句。
>
> 然而，在编写程序时遵循一些约定是非常值得的，它可以使你的代码更加容易阅读和修改。



#### 注释 - 告诉读者程序能做什么，以及怎么做

```
/*
** 这个程序从标准输入中读取输入行并在标准输出中打印这些行
** 每个输入行的后面一行是该行内容的一部分
*/
```

> 在有些语言中允许通过/**/来注释掉不需要的代码，但是在C中注释并不能嵌套
>
> 从逻辑上删除一段代码更好的办法是：
>
> ```
> #if 0
> 	statements
> #endif
> ```
>
> 在 #if 和 #endif 之间的程序段就可以从程序中去除。



### 1.1.2 预处理指令

由预处理器读入源代码并用预处理器解释的指令。

#### #include 和 #define

```x
#include <stdio.h>
#include <stdlib.h>
#define  MAX_COLS 20
```

> 在这段程序中，预处理器将 stdio.h 的内容逐字写到源文件预处理指令的位置。

**TIP**: 

如果有许多不同的文件需要相同的一些生命，可以在单独的文件中编写这些声明，然后用 #include 将这个文件包含到需要声明的文件源代码中去。



> 另一种预处理器指令是 #define ，它把名字 MAX_COLS 定义为 20，当这个名字出现在源文件的任何地方时，它就会被替换为定义的值。这些名字一般都 **大写** 。这样做的好处是易于修改 MAX_COLS 的值而不必去源代码挨个替换。



#### 函数原型

```
int read_column_numbers( int columns[], int max);
void rearrange( char *output, char const *input, int n_columns, int const columns[]);
```

> 这些声明为 **函数原型** 。他们告诉编译器这些以后将在源文件中定义的函数特征，便于准确性检查。
>
> 原型以一个类型名开头，表示返回值的类型。跟在其后的是函数名，在后面是函数期望接受的参数。
>
> columns 是一个数组，output 和 input是一个指针，带有 const 的参数表示函数将不会修改传递的这两个参数。
>
> void表示无返回值，在某些语言里，无返回值的函数称为过程。

**TIP**: 

假如一个程序的函数被多个子文件使用，那么子文件中要有 `#include somefunc`指令来包含这些函数的原型



### 1.1.3 main函数

```
int main( void )
{
	char input[MAX_INPUT];
	/*
	** 读取，处理和打印剩余的输入行。
	*/
	while( gets( input ) != NULL ){
		printf( "Original input : %s \n", input );
	}
	
	return EXIT_SUCCESS;
}
```

​	

> 软件开销的最大指出并非在于编写，而是在于维护。

**gets函数**

> gets 函数从标准输入读取一行文本并把它存储于作为参数传入的数组中。
>
> 一行输入由一串字符组成，由一个换行符结尾。
>
> 当 gets 读取到换行符时，会在该行的末尾存储一个 NUL 值。
>
> 当 gets 调用但是找不到输入行时，它就会返回一个 NULL 值。



**字符串常量**

> 字符串常量就是用 " " 括起来的一串字符
>
> 例如 "Hello" 
>
> 在内存中占据六个字节，分别为 H，e，l，l，o 和 NUL。

**TIP**:

​	NULL在 stdio.h 中定义，并不存在预定义的符号 NUL ，如果想使用它而不是字符常量 '\0' ，就得自行定义。

**print函数**

> print 函数接受多个参数
>
> 第一个参数为字符串，描述输出的格式
>
> 剩余参数就是需要打印的值。格式常常以一些字符串常量形式出现。

| 格式 | 含义                           |
| ---- | ------------------------------ |
| %d   | 以十进制的形式打印一个整形值   |
| %o   | 以八进制的形式打印一个整形值   |
| %x   | 以十六进制的形式打印一个整形值 |
| %g   | 打印一个浮点值                 |
| %c   | 打印一个字符                   |
| %s   | 打印一个字符串                 |
| \n   | 换行                           |

在最后循环结束时，main 函数返回值 EXIT_SUCCESS ( 在 stdlib.h 中定义 )。该值向操作系统提示程序成功执行，右花括号标志着 main 函数体的结束。



### 1.1.4 自定义函数



```
/*
** 读取列标号，如果超出规定范围则不予理会
*/

int read_column_numbers( int columns[], int max);
```



> 参数数组并没有申明长度，这是一个伟大的特性，它允许同一个函数操作任意长度的一维数组。
>
> 但是也有弊处，在于当你需要知道数组的长度时，就必须用其他参数传入



**scanf 函数**



```c
scanf( "%d", &columns[num] );
```

> scanf 类似于 printf ，能接受多个参数，第一个是一个格式字符串，用于描述期望的输入类型。
>
> 剩余的几个都是变量，用于储存输入的值。
>
> 如果读取失败，如类型不对或者找不到，则返回 0 。
>
> 读取成功则返回 1 。



**警告**：

所有标量参数的前面一定要加上一个 " & " 字符，但是引用值就不用加。加也没什么不对。

几乎所有的格式码（ %c 除外 ）输入值之前的空白（ 空格，制表符，换行符 ）会被跳过，值后面的空白会被表示为该值的结束。

所以 %s 并不能读取空白。

printf 和 scanf 格式代码并不完全一样！

| 格式 | 含义                     | 变量类型    |
| ---- | ------------------------ | ----------- |
| %d   | 读取一个整形值           | int         |
| %ld  | 读取一个长整型值         | long        |
| %f   | 读取一个实型值（浮点数） | float       |
| %lf  | 读取一个双精度实型值     | double      |
| %c   | 读取一个字符             | char        |
| %s   | 从输入读取一个字符串     | char 型数组 |

**TIP**：

标准并未硬性规定 C 编译器对数组下标的有效性进行检查。



**puts函数**

> 是 gets 函数的输出版本，把指定的字符串写到标准输入中去并在末尾添上一个换行符。

```
if ( num % 2 != 0 ) {
	puts( "Last column number is not paired" );
	exit( EXIT_FAILURE );
}
```



**getchar函数**

> 从标准输入中读取一个字符并且返回它的值。

```z
/*
** 这样等同于，并避免了一些冗余的语句。
*/
int ch;
while( ( ch = getchar() ) != EOF && ch != '\n');

ch = getchar()
while(ch != EOF && ch != '\n')
	ch = getchar();

```

> scanf 在读取时，只读取需要的字符。
>
> 这个语句就剔除了当前输入行的剩余字符，避免被解释为第一行从而出错。



**putchar函数**

> 能够接受一个整型参数并在标准输出中打印该字符





**TIP**:

ch 为什么被声明为整型，而事实上我们用它来读取字符。

EOF 是一个整型值，它的位数比整型要多，把ch声明为整型可以避免其他字符意外的被解释为 EOF 。

字符只是小整型数，用它来容纳一个字符值并不会引发问题。



### 1.2 编译

编译即将我们书写的代码转变为机器可识别的机器语言的过程。

分为 预处理，编译，汇编，链接四步。

#### **预处理**  .c ->.i

即预处理器执行预处理指令

```
gcc test.c -E -o test.i
```



#### **编译** .i -> .s

检查语法，如果没有错误的话，将源代码转为汇编代码

```
gcc test.c -S-o test.s
```



#### **汇编** .s -> .o

将汇编语言转变为机器语言

生成 .o 的目标文件( Object File )

```
gcc test.s -c -o test.o
```



#### 链接 .o -> .out/.exe

将相关的 .o 文件与库文件一起链接起来生成可执行文件

```
gcc test.o -o a.out
```



我们只需要执行`gcc test.o -o a.out`就可完成全过程



### 1.3 总结

本章的目的是描述足够的 C 语言的基础知识，使我们对 C 语言有一个整体的印象。

注释从 /* 开始 */ 结束，用于在程序中添加描述性的说明。

#include 用来使一个函数库头文件的内容由编译器处理，#define 允许给字面值常量取符号名。

所有的 C 程序都有一个 main 函数，它是程序执行的起点。函数的标量通过传值的方式进行传递，数组名参数句有传址调用的语义。

字符串是一串由 NUL 字节结尾的字符，并且有一组库函数专门操纵字符串。

printf，scanf 用于格式化输出输入。getchar 和 putchar 分别执行非格式化字符的输入和输出。



### 1.4 警告的总结

+ 在 scanf 函数的标量参数前未添加 & 字符。
+ 机械地把 print 函数的格式代码照搬于 scanf 函数。



### 1.5 编程提示的总结

1. 使用 #include 指令避免重复声明。
2. 使用 #define 指令给常量值取名。
3. 在 #include 文件中放置函数原型。
4. 在使用下标时要检查他们的值是否越界。
5. 在 while 和 if 中蕴含赋值操作。



## 2. 基本概念



### 2.1 环境

ANSI C 的任何一种实现中，都存在着两种环境，**翻译环境**和**执行环境**。

**翻译环境**：在这个环境里，源代码被转换为可执行的机器指令。

**执行环境**：在这个环境里代码得到执行。

**交叉编译器**能够在一台机器上运行，但是可执行代码可以运行在不同的环境中。

**独立环境**即不存在操作系统的环境。如微波炉控制器（嵌入式系统）

**宿主环境**即存在操作系统的环境。



#### 2.1.1 翻译

翻译即1.2中“编译”的全过程

+ 源代码通过**编译**转换为目标代码
+ 一或多个目标代码由**链接器**捆绑在一起形成单一完整的可执行程序

##### 编译

+ **预处理器**在源代码上进行一些文本操作
+ 源代码经过 **解析**，判断语句的意思
+ **优化器**对目标代码进行进一步优化（如果加入了优化选项



![image-20201214173524510](https://cdn.jsdelivr.net/gh/a9ia/image//blog/image-20201214173524510.png)



###### 一 文件名约定

尽管标准并没有指定文件取名规则，但是大多数环境都有必须遵守的文件名命名约定。

C 源代码通常保存在.c扩展名命名的文件中，头文件通常具有扩展名.h。

至于目标文件名，不同的环境可能有不同的约定。UNIX系统中，扩展名为.o，MS-DOS系统中，它们的扩展名是.obj。



###### 二 编译和链接

用于编译和链接 C 程序的特定指令在不同的系统中各不相同。

我们用 `gcc` 作为示例

1. 编译并链接一个完全包含于一个或多个源文件的 C 程序

```
gcc main.c sort.c lookup.c
```

当编译的文件超过一个时，目标文件不会删除，允许对程序做成更改后，只对进行过改动的源文件进行编译。



2. 编译一个 C 源文件，并把它和现存的目标文件链接在一起

```
gcc main.o sort.o lookup.c
```



3. 编译一个或多个 C 源文件，并产生一个目标文件，以后再链接

```
gcc -c program.c sort.c

// 链接
gcc program.o sort.o
```



以上的所有指令都支持加上 `-o name` 来将可执行文件保存在“name”文件中。而不是“a”（默认名）中。

`-lname`来指定链接的库为“name”。



#### 2.1.2 执行

程序的执行过程也有很多阶段。

首先，程序必须载入到内存中。在宿主环境中，这个任务由操作系统完成。在独立环境中，必须手工烧录。

然后，程序的执行就开始了。在宿主环境中，一般会有一个小型的启动程序与程序连接在一起，负责处理一系列日常事务，如收集命令行参数以便程序访问它们。

现在，便开始执行程序代码。在绝大多数机器里，程序会使用一个运行时 **堆栈**，它用于存储函数的局部变量和返回地址。程序同时也可以使用 **静态** 内存，存储于静态内存中的变量在程序结束前会一直保留他们的值。

程序执行的最后一个阶段是程序的终止。



### 2.2 词法规则

词法规则就像英语中的拼写规则，决定你在源程序中如何形成单独的字符片段，也就是标记（ token ）。

一个 C 程序由声明和函数组成。函数定义了需要执行的工作，声明则是描述了函数和（或）函数将要操作的数据类型（有时候是数据本身

）。注释可以散布于源文件的各个地方。



#### 2.2.1 字符

标准并没有规定 C 环境中使用哪种特定的字符集，但是必须包括大小写字母和一些符号。

因为有些字符集对一些符号的缺失，标准定义了 **三字符集** 即三个字母表示一个字符。

通常我们要避免`??`出现在程序中，因为这是三字符集的开头，很容易被解释为其他字符而产生错误。

当我们要使用标准中带有意义的特定字符，这时候就需要 **转义字符** 来解决这个问题。转义序列由一个`\`和其他字符组成。

![image-20201214191844718](https://cdn.jsdelivr.net/gh/a9ia/image//blog/image-20201214191844718.png)



#### 2.2.2 注释

C 语言的注释是`/**/`内，在执行编译时会被预处理器拿掉。



#### 2.2.3 自由形式的源代码

C 是一种自由形式的语言，相邻的标记之间必须出现一至多个空白字符（或者注释），不然可能被解释为单个标记。

这种代码书写的极度自由有利有弊。

[书写代码: 肥皂盒哲学](https://zhuanlan.zhihu.com/p/109447409)



#### 2.2.4 标识符

标识符就是变量，函数，类型的名字，它们由大小写字母，数字和下划线组成，但不能用数字开头。C 是大小写敏感的语言。标识符长度没有限制。

![image-20201214193738471](https://cdn.jsdelivr.net/gh/a9ia/image//blog/image-20201214193738471.png)



#### 2.2.5 程序的形式

一个 C 程序可能保存在一个或多个源文件中，一个 C 程序的源文件应该包含一组相关的函数。这样就使得抽象数据类型成为可能。



### 2.3 程序风格

一种代码风格是合理利用空格以强调程序的结构。

1. 空行用于分隔不同的逻辑代码段，它们是按照功能分段的。
2. if和相关语句的括号是这些语句的一部分，而不是它们测试的表达式的一部分。所以，在括号和表达式之间留下一个空格，使表达式看上去更突出。函数原型也是如此。
3. 在绝大多数操作符的使用中，中间都隔以空格，这可以使表达式的可读性更佳。有时在复杂表达式中，我会省略空格以助于显示子表达式的分组。
4. 嵌套于其他语句的语句将缩进，以显示层次，使用 Tab 键而不是空格。
5. 绝大部分注释都是成块出现的，这样它们从视觉上在代码中很突出。便于浏览或者跳过。
6. 在函数的定义中，返回类型出现于独立的一行中，而函数的名字则在下一行的起始处。



### 2.4 总结

一个 C 程序的源代码保存在一个或多个源文件中，但一个函数只能完整地出现在一个源文件中，要把相关的函数放在同一个文件内。每个源文件都编译，产生对应的目标文件，由链接器链接在一起产生可执行程序。编译和最终运行程序的机器可能相同可能不同。

程序必须要载入内存中才能执行。在宿主环境中，由操作系统完成这一步。在独立环境中，程序往往永久存储于 ROM 中。经过初始化的静态变量在程序执行前获得值。程序的执行起点是 main 函数。绝大多数环境使用堆栈来存储局部变量和其他数据。

C编译器所使用的字符集必须包括某些特定的字符，如果缺少这些字符可以通过三字母词来代替。转义序列使得某些无法打印的字符得以表达。

注释从`/*`开始`*/`结束，不允许嵌套。注释会被预处理器清除。标识符由字母数字和下划线组成，不能以数字开头。关键字被系统保留。C 是自由形式的代码，但是要有清楚的风格来编写源代码，这样有便于程序的阅读和维护。



### 2.5 警告的总结

1. 字符串常量中的字符被错误的解释为三字母词
2. 编写糟糕的注释
3. 注释不适当的结束。



### 2.6 编程提示的总结

良好程序风格和文档将使程序更容易阅读和维护！

